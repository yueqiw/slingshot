% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/getCurves.R
\docType{methods}
\name{getCurves}
\alias{getCurves}
\alias{getCurves,SlingshotDataSet-method}
\title{Construct Smooth Lineage Curves}
\usage{
getCurves(sds, ...)

\S4method{getCurves}{SlingshotDataSet}(sds, shrink = TRUE, extend = "y",
  reweight = TRUE, reassign = TRUE, thresh = 0.001, maxit = 15,
  stretch = 2, smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)
}
\arguments{
\item{sds}{The \code{SlingshotDataSet} for which to construct simultaneous 
principal curves. This should already have lineages identified by 
\code{\link{getLineages}}.}

\item{...}{Additional parameters to pass to scatter plot smoothing function, 
\code{smoother}.}

\item{shrink}{logical or numeric between 0 and 1, determines whether and how 
much to shrink branching lineages toward their average prior to the split.}

\item{extend}{character, how to handle root and leaf clusters of lineages 
when constructing the initial, piece-wise linear curve. Accepted values are
\code{'y'} (default), \code{'n'}, and \code{'pc1'}. See 'Details' for more.}

\item{reweight}{logical, whether to allow cells shared between lineages to be
reweighted during curve-fitting. If \code{TRUE}, cells shared between 
lineages will be iteratively reweighted based on the quantiles of their 
projection distances to each curve. See 'Details' for more.}

\item{reassign}{logical, whether to reassign cells to lineages at each 
iteration. If \code{TRUE}, cells will be added to a lineage when their 
projection distance to the curve is less than the median distance for all 
cells currently assigned to the lineage. Additionally, shared cells will be
removed from a lineage if their projection distance to the curve is above 
the 90th percentile and their weight along the curve is less than 
\code{0.1}.}

\item{thresh}{numeric, determines the convergence criterion. Percent change 
in the total distance from cells to their projections along curves must be 
less than \code{thresh}. Default is \code{0.001}, similar to 
\code{\link[princurve]{principal.curve}}.}

\item{maxit}{numeric, maximum number of iterations, see 
\code{\link[princurve]{principal.curve}}.}

\item{stretch}{numeric factor by which curves can be extrapolated beyond 
endpoints. Default is \code{2}, see
\code{\link[princurve]{principal.curve}}.}

\item{smoother, }{choice of scatter plot smoother. Same as 
\code{\link[princurve]{principal.curve}}, but \code{"lowess"} option is
replaced with \code{"loess"} for additional flexibility.}

\item{shrink.method}{character denoting how to determine the appropriate 
amount of shrinkage for a branching lineage. Accepted values are the same 
as for \code{kernel} in \code{\link{density}} (default is \code{"cosine"}),
as well as \code{"tricube"} and \code{"density"}. See 'Details' for more.}

\item{allow.breaks}{logical, determines whether curves that branch very close
to the origin should be allowed to have different starting points.}
}
\value{
An updated \code{\link{SlingshotDataSet}} object containing the 
  oringinal input, arguments provided to \code{getCurves} as well as the 
  following new elements: \itemize{ \item{curves}{A list of 
  \code{\link[princurve]{principal.curve}} objects.}
  \item{slingParams}{Additional parameters used for fitting simultaneous
  principal curves.}}
}
\description{
This function takes a reduced data matrix \code{n} by \code{p}, 
  a vector of cluster identities (optionally including \code{-1}'s for 
  "unclustered"), and a set of lineages consisting of paths through a forest 
  constructed on the clusters. It constructs smooth curves for each lineage 
  and returns the points along these curves corresponding to the orthogonal 
  projections of each data point, along with corresponding arclength 
  (\code{pseudotime} or \code{lambda}) values.
}
\details{
When there is only a single lineage, the curve-fitting algorithm is 
  nearly identical to that of \code{\link[princurve]{principal.curve}}. When
  there are multiple lineages and \code{shrink == TRUE}, an additional step
  is added to the iterative procedure, forcing curves to be similar in the
  neighborhood of shared points (ie., before they branch).

The \code{extend} argument determines how to construct the
  piece-wise linear curve used to initiate the recursive algorithm. The
  initial curve is always based on the lines between cluster centers and if
  \code{extend = 'n'}, this curve will terminate at the center of the
  endpoint clusters. Setting \code{extend = 'y'} will allow the first and
  last segments to extend beyond the cluster center to the orthogonal
  projection of the furthest point. Setting \code{extend = 'pc1'} is similar
  to \code{'y'}, but uses the first principal component of the cluster to
  determine the direction of the curve beyond the cluster center. These
  options typically have little to no impact on the final curve, but can
  occasionally help with stability issues.

When \code{shink = TRUE}, we compute a shrinkage curve,
  \eqn{w_l(t)}, for each lineage, a non-increasing function of pseudotime
  that determines how much that lineage should be shrunk toward a shared
  average curve. We set \eqn{w_l(0) = 1}, so that the curves will perfectly
  overlap the average curve at pseudotime \code{0}. The weighting curve
  decreases from \code{1} to \code{0} over the non-outlying pseudotime values
  of shared cells (where outliers are defined by the \code{1.5*IQR} rule).
  The exact shape of the curve in this region is controlled by
  \code{shrink.method}, and can follow the shape of any standard kernel
  function's cumulative density curve (or more precisely, survival curve,
  since we require a decreasing function). Different choices of
  \code{shrink.method} seem to have little impact on the final curves, in 
  most cases.

When \code{reweight = TRUE}, weights for shared cells are based on
  the quantiles of their projection distances onto each curve. The
  distances are ranked and converted into quantiles between \code{0} and
  \code{1}, which are then transformed by \code{1 - q^2}. Each cell's weight
  along a given lineage is the ratio of this value to the maximum value for
  this cell across all lineages.
}
\examples{
data("slingshotExample")
sds <- getLineages(rd, cl, start.clus = '1')
sds <- getCurves(sds)

plot(rd, col = cl, asp = 1)
lines(sds, type = 'c', lwd = 3)

}
\references{
Hastie, T., and Stuetzle, W. (1989). "Principal Curves."
  \emph{Journal of the American Statistical Association}, 84:502--516.
}
\seealso{
\code{\link{slingshot}}
}
