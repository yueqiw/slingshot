% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/slingshot.R
\docType{methods}
\name{slingshot}
\alias{slingshot}
\alias{slingshot,matrix,character-method}
\alias{slingshot,matrix,matrix-method}
\alias{slingshot,SlingshotDataSet,ANY-method}
\alias{slingshot,data.frame,ANY-method}
\alias{slingshot,matrix,numeric-method}
\alias{slingshot,matrix,factor-method}
\alias{slingshot,matrix,ANY-method}
\alias{slingshot,ClusterExperiment,ANY-method}
\alias{slingshot,SingleCellExperiment,ANY-method}
\title{Perform lineage inference with Slingshot}
\usage{
slingshot(data, clusterLabels, ...)

\S4method{slingshot}{matrix,character}(data, clusterLabels, reducedDim = NULL,
  start.clus = NULL, end.clus = NULL, dist.fun = NULL, omega = NULL,
  lineages = list(), shrink = TRUE, extend = "y", reweight = TRUE,
  drop.multi = TRUE, thresh = 0.001, maxit = 15, stretch = 2,
  smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)

\S4method{slingshot}{matrix,matrix}(data, clusterLabels, reducedDim = NULL,
  start.clus = NULL, end.clus = NULL, dist.fun = NULL, omega = NULL,
  lineages = list(), shrink = TRUE, extend = "y", reweight = TRUE,
  drop.multi = TRUE, thresh = 0.001, maxit = 15, stretch = 2,
  smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)

\S4method{slingshot}{SlingshotDataSet,ANY}(data, clusterLabels,
  reducedDim = NULL, start.clus = NULL, end.clus = NULL,
  dist.fun = NULL, omega = NULL, lineages = list(), shrink = TRUE,
  extend = "y", reweight = TRUE, drop.multi = TRUE, thresh = 0.001,
  maxit = 15, stretch = 2, smoother = "smooth.spline",
  shrink.method = "cosine", allow.breaks = TRUE, ...)

\S4method{slingshot}{data.frame,ANY}(data, clusterLabels, reducedDim = NULL,
  start.clus = NULL, end.clus = NULL, dist.fun = NULL, omega = NULL,
  lineages = list(), shrink = TRUE, extend = "y", reweight = TRUE,
  drop.multi = TRUE, thresh = 0.001, maxit = 15, stretch = 2,
  smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)

\S4method{slingshot}{matrix,numeric}(data, clusterLabels, reducedDim = NULL,
  start.clus = NULL, end.clus = NULL, dist.fun = NULL, omega = NULL,
  lineages = list(), shrink = TRUE, extend = "y", reweight = TRUE,
  drop.multi = TRUE, thresh = 0.001, maxit = 15, stretch = 2,
  smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)

\S4method{slingshot}{matrix,factor}(data, clusterLabels, reducedDim = NULL,
  start.clus = NULL, end.clus = NULL, dist.fun = NULL, omega = NULL,
  lineages = list(), shrink = TRUE, extend = "y", reweight = TRUE,
  drop.multi = TRUE, thresh = 0.001, maxit = 15, stretch = 2,
  smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)

\S4method{slingshot}{matrix,ANY}(data, clusterLabels, reducedDim = NULL,
  start.clus = NULL, end.clus = NULL, dist.fun = NULL, omega = NULL,
  lineages = list(), shrink = TRUE, extend = "y", reweight = TRUE,
  drop.multi = TRUE, thresh = 0.001, maxit = 15, stretch = 2,
  smoother = "smooth.spline", shrink.method = "cosine",
  allow.breaks = TRUE, ...)

\S4method{slingshot}{ClusterExperiment,ANY}(data, clusterLabels = NULL,
  reducedDim = NULL, start.clus = NULL, end.clus = NULL,
  dist.fun = NULL, omega = NULL, lineages = list(), shrink = TRUE,
  extend = "y", reweight = TRUE, drop.multi = TRUE, thresh = 0.001,
  maxit = 15, stretch = 2, smoother = "smooth.spline",
  shrink.method = "cosine", allow.breaks = TRUE, ...)

\S4method{slingshot}{SingleCellExperiment,ANY}(data, clusterLabels,
  reducedDim = NULL, start.clus = NULL, end.clus = NULL,
  dist.fun = NULL, omega = NULL, lineages = list(), shrink = TRUE,
  extend = "y", reweight = TRUE, drop.multi = TRUE, thresh = 0.001,
  maxit = 15, stretch = 2, smoother = "smooth.spline",
  shrink.method = "cosine", allow.breaks = TRUE, ...)
}
\arguments{
\item{data}{a data object containing the matrix of coordinates to be used for
lineage inference. Supported types include \code{matrix}, 
\code{\link{SingleCellExperiment}}, and \code{\link{SlingshotDataSet}}.}

\item{clusterLabels}{character, a vector of length \code{n} denoting cluster
labels, optionally including \code{-1}'s for "unclustered." If
\code{reducedDim} is a \code{SlingshotDataSet}, cluster labels will be
taken from it.}

\item{...}{Additional parameters to pass to scatter plot smoothing function, 
\code{smoother}.}

\item{reducedDim}{(optional) identifier to be used if \code{reducedDim(data)}
contains multiple elements. Otherwise, the first element will be used by
default.}

\item{start.clus}{(optional) character, indicates the cluster(s) of origin.
Lineages will be represented by paths coming out of this cluster.}

\item{end.clus}{(optional) character, indicates the cluster(s) which will be 
forced leaf nodes. This introduces a constraint on the MST algorithm.}

\item{dist.fun}{(optional) function, method for calculating distances between
clusters. Must take two matrices as input, corresponding to subsets of 
\code{reducedDim}. If the minimum cluster size is larger than the number
dimensions, the default is to use the joint covariance matrix to find 
squared distance between cluster centers. If not, the default is to use the
diagonal of the joint covariance matrix.}

\item{omega}{(optional) numeric, this granularity parameter determines the
distance between every real cluster and the artificial cluster, OMEGA. It
is parameterized such that this distance is \code{omega / 2}, making
\code{omega} the maximum distance between two connected clusters. By
default, \code{omega = Inf}.}

\item{lineages}{list generated by \code{\link{getLineages}}, denotes lineages
as ordered sets of clusters and contains the \code{K x K} connectivity
matrix constructed on the clusters by \code{\link{getLineages}}.}

\item{shrink}{logical or numeric between 0 and 1, determines whether and how 
much to shrink branching lineages toward their average prior to the split.}

\item{extend}{character, how to handle root and leaf clusters of lineages
when constructing the initial, piece-wise linear curve. Accepted values are
\code{'y'} (default), \code{'n'}, and \code{'pc1'}. See 'Details' for more.}

\item{reweight}{logical, whether to allow cells shared between lineages to be
reweighted during curve-fitting. If \code{TRUE}, cells shared between 
lineages will be weighted by: distance to nearest curve / distance to
curve.}

\item{drop.multi}{logical, whether to drop shared cells from lineages which
do not fit them well. If \code{TRUE}, shared cells with a distance to one 
lineage above the 90th percentile and another below the 50th will be
dropped from the further lineage.}

\item{thresh}{numeric, determines the convergence criterion. Percent change
in the total distance from cells to their projections along curves must be
less than \code{thresh}. Default is \code{0.001}, similar to 
\code{\link[princurve]{principal.curve}}.}

\item{maxit}{numeric, maximum number of iterations, see 
\code{\link[princurve]{principal.curve}}.}

\item{stretch}{numeric factor by which curves can be extrapolated beyond 
endpoints. Default is \code{2}, see \code{\link[princurve]{principal.curve}}.}

\item{smoother, }{choice of scatter plot smoother. Same as 
\code{\link[princurve]{principal.curve}}, but \code{"lowess"} option is replaced with 
\code{"loess"} for additional flexibility.}

\item{shrink.method}{character denoting how to determine the appropriate
amount of shrinkage for a branching lineage. Accepted values are the same
as for \code{kernel} in \code{\link{density}} (default is \code{"cosine"}),
as well as \code{"tricube"} and \code{"density"}. See 'Details' for more.}

\item{allow.breaks}{logical, determines whether curves that branch very close
to the origin should be allowed to have different starting points.}
}
\value{
An object of class \code{\link{SlingshotDataSet}} containing the 
  arguments provided to \code{slingshot} as well as the following output: 
  \itemize{ 
  \item{\code{lineages}}{ a list of \code{L} items, where \code{L} 
  is the number of lineages identified. Each lineage is represented by a 
  character vector with the names of the clusters included in that lineage, 
  in order.} 
  \item{\code{connectivity}}{ the inferred cluster connectivity 
  matrix.} 
  \item{\code{slingParams}}{Additional parameters used for lineage inference
  or fitting simultaneous principal curves. This may include the elements 
  \code{start.given} and \code{end.given}, logical values indicating whether 
  the starting and ending clusters were specified a priori. Additionally, 
  this will always include \code{dist}, the pairwise cluster distance 
  matrix.}
  \item{curves}{A list of \code{\link[princurve]{principal.curve}} objects.}}
}
\description{
Perform lineage inference with Slingshot

Given a reduced-dimensional data matrix \code{n} by \code{p} and
  a vector of cluster labels (or matrix of soft cluster assignments,
  potentially including a \code{-1} label for "unclustered"), this function
  performs lineage inference using a cluster-based minimum spanning tree and
  constructing simulatenous principal curves for branching paths through the
  tree.

This wrapper function performs lineage inference in two steps:
  (1) identify lineage structure with a cluster-based minimum spanning tree
  with the \code{\link{getLineages}} function and (2) construct smooth
  representations of each lineage using simultaneous principal curves from
  the function \code{\link{getCurves}}.
}
\details{
The \code{connectivity} matrix is learned by fitting a (possibly
  constrained) minimum-spanning tree on the clusters and the artificial 
  cluster, OMEGA, which is a fixed distance away from every real cluster.
  This effectively limits the maximum branch length in the MST to twice the
  chosen distance, meaning that the output may contain multiple trees.

Once the \code{connectivity} is known, lineages are identified in
  any tree with at least two clusters. For a given tree, if there is an
  annotated starting cluster, every possible path out of a starting cluster
  and ending in a leaf that isn't another starting cluster will be returned.
  If no starting cluster is annotated, every leaf will be considered as a
  potential starting cluster and whichever configuration produces the longest
  average lineage length (in terms of number of clusters included) will be
  returned.

When there is only a single lineage, the curve-fitting algorithm is
 nearly identical to that of \code{\link[princurve]{principal.curve}}. When there are 
 multiple lineages and \code{shrink == TRUE}, an additional step is added to
 the iterative procedure, forcing curves to be similar in the neighborhood
of shared points (ie., before they branch).

The \code{extend} argument determines how to construct the
  piece-wise linear curve used to initiate the recursive algorithm. The
  initial curve is always based on the lines between cluster centers and if
  \code{extend = 'n'}, this curve will terminate at the center of the
  endpoint clusters. Setting \code{extend = 'y'} will allow the first and
  last segments to extend beyond the cluster center to the orthogonal
  projection of the furthest point. Setting \code{extend = 'pc1'} is similar
  to \code{'y'}, but uses the first principal component of the cluster to
  determine the direction of the curve beyond the cluster center. These
  options typically have little to no impact on the final curve, but can
  occasionally help with stability issues.

When \code{shink == TRUE}, we compute a shrinkage curve,
  \eqn{w_l(t)}, for each lineage, a non-increasing function of pseudotime
  that determines how much that lineage should be shrunk toward a shared
  average curve. We set \eqn{w_l(0) = 1}, so that the curves will perfectly
  overlap the average curve at pseudotime \code{0}. The weighting curve
  decreases from \code{1} to \code{0} over the non-outlying pseudotime values
  of shared cells (where outliers are defined by the \code{1.5*IQR} rule).
  The exact shape of the curve in this region is controlled by
  \code{shrink.method}, and can follow the shape of any standard kernel
  function's cumulative density curve (or more precisely, survival curve,
  since we require a decreasing function). Different choices of
  \code{shrink.method} seem to have little impact on the final curves, in 
  most cases.
}
\examples{
data("slingshotExample")
sds <- slingshot(rd, cl, start.clus = '1')

plot(rd, col = cl, asp = 1)
lines(sds, lwd = 3)

}
\references{
Hastie, T., and Stuetzle, W. (1989). "Principal Curves."
  \emph{Journal of the American Statistical Association}, 84:502--516.
}
